<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mamar Coffee</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #000;
    }
    #container { 
      width: 100vw; 
      height: 100vh; 
      cursor: grab;
    }
    #container:active { cursor: grabbing; }
    .overlay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      z-index: 100;
    }
    .overlay h1 {
      font-size: 32px;
      color: #00ff88;
      text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 40px #00ff88;
      letter-spacing: 4px;
      animation: glow 2s ease-in-out infinite;
    }
    .overlay p {
      color: #b388ff;
      font-size: 14px;
      margin-top: 5px;
      opacity: 0.8;
    }
    @keyframes glow {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.2); }
    }
    .instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.5);
      font-size: 13px;
      pointer-events: none;
      z-index: 100;
    }
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff88;
      font-size: 18px;
      z-index: 200;
    }
  </style>
</head>
<body>
  <div class="overlay">
    <h1>MAMAR COFFEE</h1>
    <p>☕ Premium Brews Since 2024</p>
  </div>
  <div class="instructions">Drag to rotate • Scroll to zoom</div>
  <div id="container"></div>
  <div class="loading" id="loading">Loading...</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const container = document.getElementById('container');
    const loading = document.getElementById('loading');
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1a);
    scene.fog = new THREE.FogExp2(0x0a0a1a, 0.035);
    
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(10, 8, 12);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0x6b4a8b, 0.4);
    scene.add(ambientLight);
    
    const mainLight = new THREE.PointLight(0xffeedd, 1.5, 25);
    mainLight.position.set(0, 8, 0);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 1024;
    mainLight.shadow.mapSize.height = 1024;
    scene.add(mainLight);
    
    const pinkLight = new THREE.PointLight(0xff1493, 1.2, 18);
    pinkLight.position.set(-6, 4, 4);
    scene.add(pinkLight);
    
    const cyanLight = new THREE.PointLight(0x00ffff, 0.8, 18);
    cyanLight.position.set(6, 4, -4);
    scene.add(cyanLight);
    
    const greenLight = new THREE.PointLight(0x00ff88, 0.6, 12);
    greenLight.position.set(0, 5, 3);
    scene.add(greenLight);
    
    // Ground
    const groundGeo = new THREE.CircleGeometry(20, 64);
    const groundMat = new THREE.MeshStandardMaterial({ 
      color: 0x1a0a2e,
      roughness: 0.9,
      metalness: 0.1
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Ground glow ring
    const ringGeo = new THREE.RingGeometry(8, 12, 64);
    const ringMat = new THREE.MeshBasicMaterial({ 
      color: 0x4a1a6b,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.01;
    scene.add(ring);
    
    // Helper functions
    const createBox = (w, h, d, color, opts = {}) => {
      const mat = new THREE.MeshStandardMaterial({ 
        color,
        roughness: opts.roughness || 0.7,
        metalness: opts.metalness || 0.1,
        emissive: opts.emissive || 0x000000,
        emissiveIntensity: opts.emissiveIntensity || 0
      });
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    };
    
    const createCylinder = (rt, rb, h, color, segments = 16, opts = {}) => {
      const mat = new THREE.MeshStandardMaterial({ 
        color,
        roughness: opts.roughness || 0.6,
        metalness: opts.metalness || 0.2,
        emissive: opts.emissive || 0x000000,
        emissiveIntensity: opts.emissiveIntensity || 0
      });
      const mesh = new THREE.Mesh(new THREE.CylinderGeometry(rt, rb, h, segments), mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    };
    
    // Coffee Shop Building
    const shop = new THREE.Group();
    
    // Main walls
    const backWall = createBox(6, 4, 0.3, 0x5d3a1a);
    backWall.position.set(0, 2, -2);
    shop.add(backWall);
    
    const leftWall = createBox(0.3, 4, 4, 0x4a2d15);
    leftWall.position.set(-3, 2, 0);
    shop.add(leftWall);
    
    const rightWall = createBox(0.3, 4, 4, 0x4a2d15);
    rightWall.position.set(3, 2, 0);
    shop.add(rightWall);
    
    // Floor
    const floor = createBox(6, 0.2, 4, 0x3d2510);
    floor.position.set(0, 0.1, 0);
    shop.add(floor);
    
    // Counter
    const counterTop = createBox(4.5, 0.15, 1, 0xdeb887, { roughness: 0.4 });
    counterTop.position.set(0, 1.2, 1.5);
    shop.add(counterTop);
    
    const counterFront = createBox(4.5, 1.2, 0.15, 0xcd853f);
    counterFront.position.set(0, 0.6, 2);
    shop.add(counterFront);
    
    const counterSide1 = createBox(0.15, 1.2, 1, 0xb8733d);
    counterSide1.position.set(-2.2, 0.6, 1.5);
    shop.add(counterSide1);
    
    const counterSide2 = createBox(0.15, 1.2, 1, 0xb8733d);
    counterSide2.position.set(2.2, 0.6, 1.5);
    shop.add(counterSide2);
    
    // Roof
    const roof = createBox(7, 0.4, 5.5, 0x9932cc, { 
      emissive: 0x6b238e, 
      emissiveIntensity: 0.4,
      metalness: 0.4,
      roughness: 0.3
    });
    roof.position.set(0, 4.2, 0);
    shop.add(roof);
    
    // Roof overhang
    const overhang = createBox(6.5, 0.2, 1.8, 0x8b008b, {
      emissive: 0x4a0a4a,
      emissiveIntensity: 0.3
    });
    overhang.position.set(0, 4, 2.5);
    shop.add(overhang);
    
    // Roof trim lights
    const trimGeo = new THREE.BoxGeometry(6.8, 0.08, 0.08);
    const trimMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
    const trim = new THREE.Mesh(trimGeo, trimMat);
    trim.position.set(0, 3.95, 3.3);
    shop.add(trim);
    
    scene.add(shop);
    
    // Neon Sign
    const signGroup = new THREE.Group();
    
    const signBack = createBox(4.5, 1, 0.2, 0x111122);
    signGroup.add(signBack);
    
    const signBorder = new THREE.Mesh(
      new THREE.BoxGeometry(4.6, 1.1, 0.15),
      new THREE.MeshBasicMaterial({ color: 0x00ff88 })
    );
    signBorder.position.z = 0.08;
    signGroup.add(signBorder);
    
    const signInner = createBox(4.4, 0.9, 0.18, 0x0a0a15);
    signInner.position.z = 0.1;
    signGroup.add(signInner);
    
    const signGlow = new THREE.PointLight(0x00ff88, 2, 8);
    signGlow.position.set(0, 0, 1);
    signGroup.add(signGlow);
    
    signGroup.position.set(0, 5, 2.5);
    scene.add(signGroup);
    
    // Coffee cup icon on sign
    const cupIcon = new THREE.Group();
    const cupBody = createCylinder(0.25, 0.2, 0.5, 0xffffff, 16, { roughness: 0.3 });
    cupIcon.add(cupBody);
    
    const handle = new THREE.Mesh(
      new THREE.TorusGeometry(0.12, 0.03, 8, 16, Math.PI),
      new THREE.MeshStandardMaterial({ color: 0xffffff })
    );
    handle.rotation.z = Math.PI / 2;
    handle.rotation.y = Math.PI / 2;
    handle.position.set(0.28, 0, 0);
    cupIcon.add(handle);
    
    cupIcon.position.set(3, 5, 2.8);
    cupIcon.rotation.x = 0.2;
    scene.add(cupIcon);
    
    // Steam particles
    const steamParticles = [];
    for (let i = 0; i < 8; i++) {
      const steam = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 })
      );
      steam.position.set(3 + (Math.random() - 0.5) * 0.2, 5.3, 2.8);
      steam.userData = { 
        speed: 0.01 + Math.random() * 0.02,
        offset: Math.random() * Math.PI * 2
      };
      scene.add(steam);
      steamParticles.push(steam);
    }
    
    // Coffee cups on counter
    const createCoffeeCup = (x, z, cupColor = 0xffffff) => {
      const group = new THREE.Group();
      
      const cup = createCylinder(0.18, 0.14, 0.4, cupColor, 16, { roughness: 0.3 });
      cup.position.y = 0.2;
      group.add(cup);
      
      const coffee = createCylinder(0.15, 0.15, 0.08, 0x3d1f0d, 16);
      coffee.position.y = 0.35;
      group.add(coffee);
      
      const cupHandle = new THREE.Mesh(
        new THREE.TorusGeometry(0.1, 0.025, 8, 16, Math.PI),
        new THREE.MeshStandardMaterial({ color: cupColor, roughness: 0.3 })
      );
      cupHandle.rotation.z = Math.PI / 2;
      cupHandle.rotation.y = Math.PI / 2;
      cupHandle.position.set(0.2, 0.2, 0);
      group.add(cupHandle);
      
      group.position.set(x, 1.28, z);
      return group;
    };
    
    scene.add(createCoffeeCup(-1.2, 1.3, 0xffffff));
    scene.add(createCoffeeCup(-0.4, 1.4, 0xff6b6b));
    scene.add(createCoffeeCup(0.4, 1.3, 0x87ceeb));
    scene.add(createCoffeeCup(1.2, 1.4, 0xffd700));
    
    // Espresso Machine
    const machine = new THREE.Group();
    const machineBody = createBox(0.8, 1, 0.6, 0xc0c0c0, { metalness: 0.8, roughness: 0.2 });
    machineBody.position.y = 0.5;
    machine.add(machineBody);
    
    const machineTop = createBox(0.85, 0.15, 0.65, 0x8b0000);
    machineTop.position.y = 1.05;
    machine.add(machineTop);
    
    const gauge = createCylinder(0.08, 0.08, 0.05, 0x222222, 16);
    gauge.rotation.x = Math.PI / 2;
    gauge.position.set(0, 0.7, 0.32);
    machine.add(gauge);
    
    machine.position.set(1.8, 1.28, 1.2);
    scene.add(machine);
    
    // Stools
    const createStool = (x, z) => {
      const group = new THREE.Group();
      
      const seat = createCylinder(0.35, 0.3, 0.12, 0xcd853f, 16, { roughness: 0.5 });
      seat.position.y = 0.75;
      group.add(seat);
      
      const leg = createCylinder(0.06, 0.1, 0.75, 0x4a3520, 8);
      leg.position.y = 0.375;
      group.add(leg);
      
      const base = createCylinder(0.25, 0.25, 0.05, 0x3a2510, 16);
      base.position.y = 0.025;
      group.add(base);
      
      group.position.set(x, 0, z);
      return group;
    };
    
    scene.add(createStool(-1.3, 3.2));
    scene.add(createStool(0, 3.5));
    scene.add(createStool(1.3, 3.2));
    
    // 3D Billboard Cards
    const billboards = [];
    
    const createBillboard = (label, color, pos, rotY) => {
      const group = new THREE.Group();
      
      // Post
      const post = createCylinder(0.08, 0.12, pos.y, 0x2a2a2a, 8, { metalness: 0.6 });
      post.position.y = pos.y / 2;
      group.add(post);
      
      // Frame
      const frame = createBox(2.2, 1.2, 0.2, 0x1a1a1a, { metalness: 0.4 });
      frame.position.y = pos.y + 0.6;
      group.add(frame);
      
      // Glowing face
      const face = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1, 0.15),
        new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.6,
          roughness: 0.2,
          metalness: 0.3
        })
      );
      face.position.set(0, pos.y + 0.6, 0.1);
      group.add(face);
      
      // Border glow
      const borderMat = new THREE.MeshBasicMaterial({ color: color });
      const borderTop = new THREE.Mesh(new THREE.BoxGeometry(2.1, 0.05, 0.18), borderMat);
      borderTop.position.set(0, pos.y + 1.1, 0.1);
      group.add(borderTop);
      
      const borderBottom = new THREE.Mesh(new THREE.BoxGeometry(2.1, 0.05, 0.18), borderMat);
      borderBottom.position.set(0, pos.y + 0.1, 0.1);
      group.add(borderBottom);
      
      // Light
      const light = new THREE.PointLight(color, 0.8, 5);
      light.position.set(0, pos.y + 0.6, 1);
      group.add(light);
      
      group.position.set(pos.x, 0, pos.z);
      group.rotation.y = rotY;
      
      return { group, face, light };
    };
    
    const billboardData = [
      { label: 'PROJECTS', color: 0xff1493, pos: { x: -5.5, y: 2, z: 4 }, rot: 0.4 },
      { label: 'MENU', color: 0x00ced1, pos: { x: -6, y: 1.8, z: -1 }, rot: 1 },
      { label: 'ABOUT', color: 0x32cd32, pos: { x: -5, y: 2.2, z: -4 }, rot: 1.5 },
      { label: 'CONTACT', color: 0xffa500, pos: { x: 5.5, y: 2, z: 3 }, rot: -0.4 }
    ];
    
    billboardData.forEach(data => {
      const bb = createBillboard(data.label, data.color, data.pos, data.rot);
      scene.add(bb.group);
      billboards.push(bb);
    });
    
    // Signpost
    const signpost = new THREE.Group();
    
    const mainPost = createCylinder(0.1, 0.15, 5, 0x2a2a2a, 8, { metalness: 0.5 });
    mainPost.position.y = 2.5;
    signpost.add(mainPost);
    
    const createArrowSign = (color, y, angle, length = 1.8) => {
      const sign = createBox(length, 0.45, 0.12, color, {
        emissive: color,
        emissiveIntensity: 0.4
      });
      sign.position.set(length / 2 + 0.1, y, 0);
      sign.rotation.y = angle;
      return sign;
    };
    
    signpost.add(createArrowSign(0xff69b4, 4.5, 0.15));
    signpost.add(createArrowSign(0x40e0d0, 3.9, -0.1));
    signpost.add(createArrowSign(0x98fb98, 3.3, 0.2));
    signpost.add(createArrowSign(0xffd700, 2.7, -0.15));
    
    signpost.position.set(5, 0, -3);
    scene.add(signpost);
    
    // Street Lamps
    const createLamp = (x, z, armDir = 1) => {
      const group = new THREE.Group();
      
      const pole = createCylinder(0.08, 0.12, 5, 0x3d2a5a, 8, { metalness: 0.4 });
      pole.position.y = 2.5;
      group.add(pole);
      
      const arm = createBox(1.5, 0.1, 0.1, 0x3d2a5a);
      arm.position.set(0.75 * armDir, 4.8, 0);
      group.add(arm);
      
      const bulbGlow = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0xfffacd })
      );
      bulbGlow.position.set(1.4 * armDir, 4.5, 0);
      group.add(bulbGlow);
      
      const light = new THREE.PointLight(0xffd700, 1.5, 10);
      light.position.set(1.4 * armDir, 4.5, 0);
      light.castShadow = true;
      group.add(light);
      
      group.position.set(x, 0, z);
      return { group, light, bulb: bulbGlow };
    };
    
    const lamp1 = createLamp(-4.5, 5, 1);
    const lamp2 = createLamp(4.5, 5, -1);
    scene.add(lamp1.group);
    scene.add(lamp2.group);
    
    // Chalkboard
    const chalkboard = new THREE.Group();
    const boardBack = createBox(1, 1.4, 0.08, 0x1a1a1a);
    chalkboard.add(boardBack);
    
    const boardFrame = createBox(1.1, 1.5, 0.05, 0x5d3a1a);
    boardFrame.position.z = -0.04;
    chalkboard.add(boardFrame);
    
    const standLeft = createBox(0.08, 1.2, 0.08, 0x4a2d15);
    standLeft.position.set(-0.4, -0.6, 0.3);
    standLeft.rotation.x = 0.2;
    chalkboard.add(standLeft);
    
    const standRight = createBox(0.08, 1.2, 0.08, 0x4a2d15);
    standRight.position.set(0.4, -0.6, 0.3);
    standRight.rotation.x = 0.2;
    chalkboard.add(standRight);
    
    chalkboard.position.set(5, 1, 5);
    chalkboard.rotation.y = -0.8;
    scene.add(chalkboard);
    
    // Floating particles
    const particles = [];
    for (let i = 0; i < 50; i++) {
      const p = new THREE.Mesh(
        new THREE.SphereGeometry(0.03, 6, 6),
        new THREE.MeshBasicMaterial({ 
          color: Math.random() > 0.5 ? 0xff69b4 : 0x00ffff,
          transparent: true,
          opacity: 0.5
        })
      );
      p.position.set(
        (Math.random() - 0.5) * 25,
        Math.random() * 10,
        (Math.random() - 0.5) * 25
      );
      p.userData = {
        speed: 0.005 + Math.random() * 0.01,
        offset: Math.random() * Math.PI * 2
      };
      scene.add(p);
      particles.push(p);
    }
    
    // Mouse/Touch controls
    let isDragging = false;
    let previousMouse = { x: 0, y: 0 };
    let spherical = { theta: Math.PI / 4, phi: Math.PI / 3, radius: 16 };
    let targetSpherical = { ...spherical };
    let autoRotate = true;
    let lastInteraction = 0;
    
    const onPointerDown = (e) => {
      isDragging = true;
      autoRotate = false;
      lastInteraction = Date.now();
      const pos = e.touches ? e.touches[0] : e;
      previousMouse = { x: pos.clientX, y: pos.clientY };
    };
    
    const onPointerMove = (e) => {
      if (!isDragging) return;
      const pos = e.touches ? e.touches[0] : e;
      const deltaX = pos.clientX - previousMouse.x;
      const deltaY = pos.clientY - previousMouse.y;
      
      targetSpherical.theta -= deltaX * 0.005;
      targetSpherical.phi -= deltaY * 0.005;
      targetSpherical.phi = Math.max(0.3, Math.min(Math.PI / 2 - 0.1, targetSpherical.phi));
      
      previousMouse = { x: pos.clientX, y: pos.clientY };
    };
    
    const onPointerUp = () => {
      isDragging = false;
      lastInteraction = Date.now();
    };
    
    const onWheel = (e) => {
      e.preventDefault();
      targetSpherical.radius += e.deltaY * 0.01;
      targetSpherical.radius = Math.max(8, Math.min(25, targetSpherical.radius));
      lastInteraction = Date.now();
      autoRotate = false;
    };
    
    container.addEventListener('mousedown', onPointerDown);
    container.addEventListener('mousemove', onPointerMove);
    container.addEventListener('mouseup', onPointerUp);
    container.addEventListener('mouseleave', onPointerUp);
    container.addEventListener('touchstart', onPointerDown, { passive: true });
    container.addEventListener('touchmove', onPointerMove, { passive: true });
    container.addEventListener('touchend', onPointerUp);
    container.addEventListener('wheel', onWheel, { passive: false });
    
    // Animation
    let time = 0;
    loading.style.display = 'none';
    
    const animate = () => {
      requestAnimationFrame(animate);
      time += 0.016;
      
      // Auto rotate after 3 seconds
      if (!isDragging && Date.now() - lastInteraction > 3000) {
        autoRotate = true;
      }
      
      if (autoRotate) {
        targetSpherical.theta += 0.003;
      }
      
      // Smooth camera interpolation
      spherical.theta += (targetSpherical.theta - spherical.theta) * 0.05;
      spherical.phi += (targetSpherical.phi - spherical.phi) * 0.05;
      spherical.radius += (targetSpherical.radius - spherical.radius) * 0.05;
      
      camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
      camera.position.y = spherical.radius * Math.cos(spherical.phi);
      camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
      camera.lookAt(0, 2, 0);
      
      // Animate neon sign
      signGlow.intensity = 2 + Math.sin(time * 3) * 0.5;
      
      // Animate billboards
      billboards.forEach((bb, i) => {
        const pulse = 0.6 + Math.sin(time * 2 + i * 0.8) * 0.2;
        bb.face.material.emissiveIntensity = pulse;
        bb.light.intensity = 0.8 + Math.sin(time * 2 + i * 0.8) * 0.3;
      });
      
      // Animate lamps
      lamp1.light.intensity = 1.5 + Math.sin(time * 1.5) * 0.2;
      lamp2.light.intensity = 1.5 + Math.sin(time * 1.5 + 1) * 0.2;
      
      // Animate steam
      steamParticles.forEach((p, i) => {
        p.position.y += p.userData.speed;
        p.position.x = 3 + Math.sin(time * 2 + p.userData.offset) * 0.15;
        p.material.opacity = 0.6 - ((p.position.y - 5.3) * 0.4);
        if (p.position.y > 6.5) {
          p.position.y = 5.3;
          p.position.x = 3 + (Math.random() - 0.5) * 0.2;
        }
      });
      
      // Animate floating particles
      particles.forEach((p, i) => {
        p.position.y += p.userData.speed;
        p.position.x += Math.sin(time + p.userData.offset) * 0.005;
        if (p.position.y > 12) {
          p.position.y = -1;
          p.position.x = (Math.random() - 0.5) * 25;
          p.position.z = (Math.random() - 0.5) * 25;
        }
      });
      
      // Subtle light color shifts
      pinkLight.intensity = 1.2 + Math.sin(time * 0.8) * 0.3;
      cyanLight.intensity = 0.8 + Math.sin(time * 0.6 + 1) * 0.2;
      
      renderer.render(scene, camera);
    };
    
    animate();
    
    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
